                      //题目：将矩阵中与0相同的行、列的数字全部归零
//负责完成检查和输出（包括0的赋值）
void checkAndprint(int rows, int cols,int (*p)[cols]){
    int point_row[rows * cols], point_col[cols * rows];//分别负责记录0出现的坐标，同时也能担当计数器
    int i, j, n = 0, m = 0;//m,n刚开始作为矩阵中0个数的计数器，后作为数组的元素顺序
    int row_cnt = 0, col_cnt = 0;//m和n把个数赋值给它们之后，负责最后担当输出的计数上限

    //遍历数组寻找0
    for ( i = 0; i < rows; i++){
        for ( j = 0; j < cols; j++){
            //找到0之后记录坐标（行row列col）
            if ( *(*(p+i)+j) == 0 ){
                point_row[n++] = i;
                point_col[m++] = j;
            }

        }
    }

    row_cnt = n, col_cnt = m;//赋予0的个数
   
    //布置一竖列的0，不动行
    for ( m = 0; m < col_cnt; m++){    
        for ( j = point_col[m], i = 0; i < rows; i++){
            *(*(p+i)+j) = 0;// 写法 1：通过指针运算 + 多次解引用显式访问二维数组元素
                            //（先通过 p + i 定位到第 i 行，解引用后再通过 + j 定位到该行第 j 列，最后解引用赋值）
        }
    }
    //布置一横排的0，不动列
    for ( n = 0; n < row_cnt; n++){
        for ( i = point_row[n], j = 0; j < cols; j++){
            p[i][j] = 0;// 写法 2：通过数组下标语法糖访问二维数组元素
                        //（是编译器提供的简化写法，本质上会被转换为写法 1 的指针运算逻辑，更直观易读）
        }
    }

    //遍历 打印
    for ( int cnt = 0, i = 0; i < rows; i++){
        for ( j = 0; j < cols; j++){
            printf("%d ",p[i][j]);
            cnt++;//满足列的最大值之后换行
            if (cnt == cols){
                putchar('\n');
                cnt = 0;
            }
        }
    }
}

int main(){
    int n, m, i, j;
    scanf("%d %d",&n,&m);
    int a[n][m];

    //二维数组读取数字
    for ( i = 0; i < n; i++){
        for ( j = 0; j < m; j++){
            scanf("%d",&a[i][j]);
        }
    }

    int (*p)[m] = a;//行指针：中括号内的是一维数组内的元素个数，这里可以把二维数组里的一维数组当成一个元素，
                    //而二维数组能看成一维数组

    checkAndprint(n,m,p);

    return 0;
}
