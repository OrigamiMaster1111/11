#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// 栈结构体定义
typedef struct {
    char* bracket;
    int capacity;
    int top;
} Stack;

// 初始化栈
Stack* initStack(int capacity) {
    // 检查容量合法性
    if (capacity <= 0) {
        printf("栈初始化失败：容量必须大于0\n");
        return NULL;
    }
    // 分配栈结构体内存
    Stack* stack = (Stack*)malloc(sizeof(Stack));
    if (stack == NULL) {
        printf("栈初始化失败：内存分配失败\n");
        return NULL;
    }
    // 分配括号数组内存
    stack->bracket = (char*)malloc(capacity * sizeof(char));
    if (stack->bracket == NULL) {
        printf("栈初始化失败：括号数组内存分配失败\n");
        free(stack); // 释放已分配的栈结构体
        return NULL;
    }
    stack->top = -1; // 空栈
    stack->capacity = capacity;
    return stack;
}

// 括号匹配检查函数（带安全判断）
bool check_pop_push(Stack* stack, const char* newChar) {
    if (stack == NULL || newChar == NULL) {
        printf("错误：栈或输入字符串为空指针\n");
        return false;
    }

    int i = 0;
    while (*(newChar + i) != '\0') {
        char current_char = *(newChar + i);

        if (current_char == '(' || current_char == '[' || current_char == '{') {
            // 栈满检查
            if (stack->top + 1 >= stack->capacity) {
                printf("错误：栈已满，无法入栈'%c'\n", current_char);
                return false;
            }
            stack->top++;
            stack->bracket[stack->top] = current_char;
        } else if (current_char == ')' || current_char == '}' || current_char == ']') {
            // 栈空检查（右括号无匹配）
            if (stack->top == -1) {
                printf("错误：右括号'%c'无匹配左括号\n", current_char);
                return false;
            }
            char top_char = stack->bracket[stack->top];
            // 匹配判断
            if ((top_char == '(' && current_char == ')') || 
                (top_char == '{' && current_char == '}') || 
                (top_char == '[' && current_char == ']')) {
                stack->top--;
            } else {
                printf("错误：不匹配 - 栈顶'%c' vs 当前'%c'\n", top_char, current_char);
                return false;
            }
        } else {
            printf("错误：无效字符'%c'\n", current_char);
            return false;
        }
        i++;
    }

    // 最终检查栈是否为空
    if (stack->top == -1) {
        printf("测试结果：所有括号匹配成功！\n\n");
        return true;
    } else {
        printf("错误：存在未匹配的左括号（剩余%d个）\n\n", stack->top + 1);
        return false;
    }
}

// 主函数：测试用例
int main() {
    // 初始化栈（容量10，足够测试一般情况）
    Stack* stack = initStack(10);
    if (stack == NULL) {
        return 1; // 栈初始化失败，退出程序
    }

    // 测试用例1：正常匹配（正确情况）
    printf("测试用例1：\"()[]{}\"\n");
    check_pop_push(stack, "()[]{}");

    // 测试用例2：括号不匹配（类型错误）
    printf("测试用例2：\"([)]\"\n");
    check_pop_push(stack, "([)]");

    // 测试用例3：右括号多余（无对应左括号）
    printf("测试用例3：\"())\"\n");
    check_pop_push(stack, "())");

    // 测试用例4：左括号多余（无对应右括号）
    printf("测试用例4：\"(({\"\n");
    check_pop_push(stack, "(({");

    // 测试用例5：包含无效字符
    printf("测试用例5：\"(a)[b]\"\n");
    check_pop_push(stack, "(a)[b]");

    // 释放内存（避免内存泄漏）
    free(stack->bracket); // 先释放括号数组
    free(stack);          // 再释放栈结构体
    return 0;
}
