# 语句

- **核心定义**：JavaScript 程序的执行单位是“行”，通常一行就是一个语句，程序会按顺序逐行执行。
- **语法规则**：语句必须以**分号（;）**结尾，分号代表一个语句的结束。
    
    ```jsx
    var num = 10; // 这是一个完整的变量声明语句
    ```
    

<aside>
💡

- **注意**：JavaScript 允许省略分号，但不推荐，省略分号可能导致语法解析错误或意外行为。
</aside>

---

# 标识符

- **核心定义**：用于识别变量、函数、对象属性等的合法名称，最常见的用途是作为变量名。
- **命名规则**：
    
    
    | 允许字符 | 禁止规则 |
    | --- | --- |
    | 字母（`a-z`、`A-Z`）、美元符号（`$`）、下划线（`_`）、数字 | 不能以数字开头；不能使用 JavaScript 保留字（如 `var`、`function`、`if` 等） |
- **示例**：
    
    ```jsx
    var username = "小明"; // 合法
    var $userAge = 20;    // 合法（以$开头）
    var _isActive = true; // 合法（以下划线开头）
    var 123num = 100;     // 不合法（以数字开头）
    var var = "test";     // 不合法（使用保留字）
    ```
    

<aside>
💡

- **提示**：中文是合法的标识符（如 `var 年龄 = 25;`），但不推荐使用，因为可读性差且可能存在编码兼容性问题。
</aside>

---

# JavaScript 保留关键字

```jsx
arguments、break、case、catch、class、const、
continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、
for、function、if、implements、import、in、instanceof、interface、let、new、null、package、
private、protected、public、return、static、super、switch、this、throw、true、try、typeof、
var、void、while、with、yield
```



# 变量重新赋值

这是变量的基础特性，用 `var` 声明的变量可以被多次修改值：

```jsx
var num = 10; // 首次声明并赋值
num = 20;     // 重新赋值，变量num的值从10变为20
```

---

# 变量提升

### 原理

JavaScript 引擎会先解析代码，把所有 `var` 声明的变量提升到当前作用域的顶部，但**赋值操作不会被提升**。

### 示例

看这段代码：

```jsx
console.log(num); // 输出 undefined
var num = 10;
```

实际执行顺序等价于：

```jsx
var num; // 变量声明被提升到作用域顶部（此时未赋值，默认值为 undefined）
console.log(num); // 输出 undefined
num = 10; // 赋值操作留在原位置执行
```

所以，虽然 `console.log(num)` 写在 `var num = 10` 前面，但不会报错，而是输出 `undefined`。

### 关键注意点

- 变量提升只提升**声明**，不提升**赋值**。
- `let` 和 `const` 不存在变量提升，会触发暂时性死区（TDZ），这是 ES6 对 `var` 的改进。

---




# 嵌入到HTML文件中

```html
<body>
		<script>
				var age = 20;
		</script>
</body>
```

# 引入本地独立的JS文件

```html
<body>
		<script type="text/javascript" src="./xxxx.js">         </script>
</body>
```

# 引入网络来源文件

```html
<body>
		<script src="http://code.jquery.com/jquery1.2.1min.js">      </script>
<body>
```




# JavaScript 注释

注释是代码中**不会被引擎执行的文本**，作用是解释代码逻辑、提高可读性，也可用于临时屏蔽代码执行。

### JavaScript 中的两种注释

| 类型 | 语法 | 适用场景 |
| --- | --- | --- |
| **单行注释** | `// 注释内容` | 简短的代码说明、临时屏蔽单行代码 |
| **多行注释** | `/* 注释内容 */` | 大段的功能说明、临时屏蔽多行代码 |

```jsx
// 单行注释：声明一个变量并赋值
var num = 10;

/*
  多行注释：
  这是一个用于计算的函数
  接收两个参数，返回它们的和
*/
function add(a, b) {
  return a + b;
}
```

### 嵌入在 HTML 中的注释

这是 HTML 语言的注释语法，而非 JavaScript 注释，用于在 HTML 文件中添加说明：

```html
<!-- 这是 HTML 注释，不会在页面显示 -->
<div>页面内容</div>
```

如果在 HTML 中嵌入 JavaScript，建议使用 JavaScript 注释，而非 HTML 注释，避免兼容性问题。

---

# JavaScript 输出方式

### `alert()` 弹窗输出

```jsx
alert("要输出的内容");
```

- **功能**：在浏览器中弹出一个模态对话框，将输出内容转换为字符串后显示。
- **特点**：会阻塞页面交互（必须关闭弹窗才能继续操作），仅适合简单的信息提示或极早期的调试。
- **适用场景**：快速验证代码执行结果（开发初期）、向用户展示重要提示。

### `document.write()` 页面输出

```jsx
document.write("要输出的内容");

```

- **功能**：直接将内容写入 HTML 文档流。
- **特点**：
    - 页面加载完成前调用：内容会插入到当前文档位置。
    - 页面加载完成后调用：会清空整个页面并重新写入内容（强烈不推荐）。
- **适用场景**：仅在页面初始化时动态生成简单内容，现代开发中已很少使用。

### `console.log()` 控制台输出

```jsx
console.log("要输出的内容");

```

- **功能**：在浏览器开发者工具的控制台中输出内容，支持字符串、对象、数组等多种数据类型。
- **特点**：不影响页面显示，不会阻塞交互，是开发中最常用的调试方式。
- **适用场景**：日常开发调试、复杂数据（如对象、数组）的查看、错误排查。

---

### 对比表

| 方法 | 输出位置 | 适用场景 | 优缺点 |
| --- | --- | --- | --- |
| `alert()` | 弹窗 | 简单提示、早期调试 | 优点：直观；缺点：阻塞页面、仅支持字符串 |
| `document.write()` | HTML 页面 | 页面初始化时输出内容 | 优点：直接显示在页面；缺点：加载完成后调用会覆盖页面 |
| `console.log()` | 开发者控制台 | 日常调试、复杂数据查看 | 优点：不影响页面、支持多类型、无阻塞；缺点：普通用户不可见 |

### 建议

- **优先使用 `console.log()`**：这是现代前端开发的标准调试方式，配合开发者工具可以高效排查问题。
- **避免滥用 `alert()`**：频繁弹窗会严重影响用户体验，仅在必要时使用。
- **谨慎使用 `document.write()`**：页面加载完成后调用会导致页面被清空，通常可通过 DOM 操作（如 `innerHTML`）替代。






# 分类

## 基础六种数据类型

分为**原始类型（值类型）和引用类型（复杂类型）**：

| 类型分类 | 具体类型 | 特点与示例 |
| --- | --- | --- |
| **原始类型（值类型）** | `String` | 字符串，用单/双/反引号包裹，如 `"hello"`、`'world'`、`${name}` |
|  | `Number` | 数字，包含整数、浮点数、`NaN`（非数字）、`Infinity`（无穷大），如 `10`、`3.14` |
|  | `Boolean` | 布尔值，仅包含 `true`（真）和 `false`（假）两个值 |
|  | `Undefined` | 变量声明后未赋值时的默认值，如 `var a; console.log(a); // undefined` |
|  | `Null` | 表示“主动设置的空值”，是一个空引用，如 `var b = null;` |
| **引用类型（复杂类型）** | `Object` | 包含普通对象、数组（`Array`）、函数（`Function`）、日期（`Date`）等，如 `{name: "小明"}`、`[1,2,3]` |

## ES6 新增

1. **`Symbol`（第七种）**：表示唯一、不可重复的值，主要用于对象属性的唯一标识，避免属性名冲突，例如：
    
    ```jsx
    const id = Symbol('user-id');
    const user = { [id]: 123 };
    ```
    
2. **`BigInt`（第八种）**：用于表示超出 `Number` 类型范围的大整数（`Number` 最大安全整数为 `2^53-1`），例如：
    
    ```jsx
    const bigNum = 123456789012345678901234567890n;
    ```
    

---

# 原始类型

- **定义**：最基础、不可再分的数据类型，值直接存储在栈内存中。
- **包含类型**：`String`、`Number`、`Boolean`、`Undefined`、`Null`（ES6 新增的 `Symbol`、`BigInt` 也属于原始类型）
- **核心特点**：
    1. **值不可变**：原始类型的值一旦创建就无法修改，看似修改其实是生成了新值。
    2. **值传递**：赋值时会复制值本身，多个变量互不影响。
- **示例**：
    
    ```jsx
    let a = 10;
    let b = a;
    b = 20;
    console.log(a); // 输出 10（a 不受 b 修改的影响）
    ```
    

# 合成类型

![image.png](attachment:ad1e9a3e-9f12-4531-af58-b4c5f02ead04:image.png)

- **定义**：由多个原始类型（或其他合成类型）组合而成的复杂数据类型，值存储在堆内存中，栈内存仅保存指向堆内存的引用地址。
- **主要类型**：`Object`（包含普通对象、数组 `Array`、函数 `Function`、日期 `Date` 等）。
- **核心特点**：
    1. **值可变**：可以直接修改对象的属性或数组的元素，无需生成新值。
    2. **引用传递**：赋值时复制的是内存地址，多个变量指向同一个对象，修改一个会影响所有指向它的变量。
- **示例**：
    
    ```jsx
    let obj1 = { name: "小明" };
    let obj2 = obj1;
    obj2.name = "小红";
    console.log(obj1.name); // 输出 "小红"（obj1 和 obj2 指向同一个对象，修改会互相影响）
    ```
    

---

# 核心区别

| 维度 | 原始类型 | 合成类型 |
| --- | --- | --- |
| 存储位置 | 栈内存 | 堆内存（栈内存存引用地址） |
| 值的可变性 | 不可变 | 可变 |
| 赋值方式 | 值传递（复制值本身） | 引用传递（复制内存地址） |
| 类型示例 | `let str = "hello";` | `let arr = [1,2,3];` |

<aside>
💡

undefined和null，一般将他们看成两个特殊值

</aside>





`typeof` 是 JavaScript 中最常用的类型检测方式，它会返回一个字符串，表示变量的类型。

### 返回值示例

| 数据类型 | 代码示例 | 返回值 |
| --- | --- | --- |
| 数值（Number） | `typeof 123` | `"number"` |
| 字符串（String） | `typeof '123'` | `"string"` |
| 布尔值（Boolean） | `typeof false` | `"boolean"` |
| 对象（Object） | `typeof {}` | `"object"` |
| 数组（Array） | `typeof []` | `"object"`（数组属于对象的一种，这是 `typeof` 的局限性） |
| 函数（Function） | `typeof function() {}` | `"function"`（函数是特殊的对象，`typeof` 会单独识别） |
| 未定义（Undefined） | `typeof undefined` | `"undefined"` |
| 空值（Null） | `typeof null` | `"object"`（历史遗留问题，`null` 本质是原始类型，但 `typeof` 误判为对象） |

### `null` 与 `undefined` 的核心区别

两者都表示“空/无”，但含义和使用场景有本质不同：

| 维度 | `undefined` | `null` |
| --- | --- | --- |
| **含义** | 表示“未定义”，即变量声明后未赋值时的默认状态。 | 表示“主动设置的空值”，即开发者明确表示变量当前没有值。 |
| **产生场景** | 1. 变量声明后未赋值：`var a; console.log(a);`<br>2. 函数调用时未传的参数：`function fn(a) { console.log(a); } fn();`<br>3. 函数无返回值时的默认返回：`function fn() {} console.log(fn());` | 1. 主动赋值表示空值：`var b = null;`<br>2. 清空对象引用：`var obj = {name: "小明"}; obj = null;` |
| **`typeof` 返回值** | `"undefined"` | `"object"`（历史 Bug，需注意） |
| **历史原因** | JavaScript 设计初期为了区分“未赋值”和“主动设空”而引入，后来成为语言规范。 | 早期 JavaScript 中 `null` 被设计为对象的空引用，但 `typeof` 误判为对象，这个问题一直保留至今。 |





## 加减乘除运算符

```jsx
10 + 10;  //20
100 - 10; //90
10 * 2;   //20
10 / 5;   //2
```

## 自增和自减运算符

自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上 1 或者减去 1

```jsx
var x = 1;
var y = 1;
++x // 2
--y // 0
```

自增和自减运算符有一个`需要注意`的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。

```jsx
var x = 1;
var y = 1;

x++ // 1
++y // 2
```

```jsx
var x = 10;
var y = 20;
console.log(x++ + y);// 30
```




赋值运算符（Assignment Operators）用于给变量赋值

## 最常见的赋值运算符，当然就是等号（=）

```jsx
// 将 1 赋值给变量 x
var x = 1;
```

```jsx
// 将变量 y 的值赋值给变量 x
var x = y;
```

赋值运算符还可以与其他运算符结合，形成变体。下面是与算术运算符的结合

```jsx
// 等同于 x = x + y
x += y

// 等同于 x = x - y
x -= y

// 等同于 x = x * y
x *= y

// 等同于 x = x / y
x /= y

// 等同于 x = x % y
x %= y
```





## 关系比较运算符

用于比较值的大小关系，支持数字、字符串等类型的比较（字符串会按 Unicode 码点比较）。

| 运算符 | 描述 | 示例 |
| --- | --- | --- |
| `<` | 小于 | `2 < 3 → true`；`'a' < 'b' → true`（按 Unicode 码点比较） |
| `>` | 大于 | `2 > 3 → false`；`'z' > 'a' → true` |
| `<=` | 小于或等于 | `2 <= 2 → true`；`'10' <= '2' → true`（字符串按字符比较，'1'的码点小于'2'） |
| `>=` | 大于或等于 | `3 >= 2 → true`；`'10' >= '2' → false` |

---

## 相等性比较运算符

用于比较两个值是否相等，核心区别在于是否进行**类型转换**。

| 运算符 | 描述 | 示例 |
| --- | --- | --- |
| `==` | 相等（会自动类型转换） | `2 == '2' → true`（字符串转数字后比较）；`null == undefined → true`（历史遗留规则） |
| `===` | 严格相等（**不进行类型转换**，同时比较值和类型） | `2 === '2' → false`（类型不同）；`null === undefined → false`（类型不同） |
| `!=` | 不相等（会自动类型转换） | `2 != '2' → false`；`null != undefined → false` |
| `!==` | 严格不相等（**不进行类型转换**） | `2 !== '2' → true`；`null !== undefined → true` |

---

### 建议

1. **优先使用严格相等（`===`）**：`==` 的自动类型转换会导致很多意外结果（如 `0 == false → true`、`'' == false → true`），而 `===` 同时比较值和类型，结果更可靠，是开发中的首选。
2. **避免依赖 `==` 的类型转换**：除非你明确需要利用类型转换的场景（如判断 `null` 或 `undefined` 时用 `value == null`），否则尽量用 `===`。
3. **字符串比较注意点**：字符串比较是按单个字符的 Unicode 码点进行的，因此 `'10' < '2'` 会返回 `true`（因为 `'1'` 的码点小于 `'2'`），若需按数字大小比较，需先转换为数字。







## 布尔值取反

```jsx
!true  // false
!false // true
```

## 非布尔值取反

对非布尔值取反时，JavaScript 会先将其**隐式转换为布尔值**，再进行取反。

以下6个值在转换为布尔值时为 `false`，因此取反后为 `true`：

| 假值类型 | 示例 | 取反结果 |
| --- | --- | --- |
| `undefined` | `!undefined` | `true` |
| `null` | `!null` | `true` |
| `false` | `!false` | `true` |
| `0` | `!0` | `true` |
| `NaN` | `!NaN` | `true` |
| 空字符串 `""` | `!""` | `true` |

其他所有值取反为 `false`

除了上述6个假值，其他所有值（非零数字、非空字符串、对象、数组等）转换为布尔值时为 `true`，因此取反后为 `false`：

```jsx
!"hello"  // false（非空字符串为真，取反为假）
!123      // false（非零数字为真，取反为假）
![]       // false（数组为对象，属于真值，取反为假）
!{}       // false（对象为真值，取反为假）
```

### 双取反快速转布尔值

可以用 `!!`（两次取反）将任意值转换为对应的布尔值

```jsx
!!"hello"  // true（非空字符串 → 真）
!!0        // false（0 → 假）
!![]       // true（数组 → 真）
!!null     // false（null → 假）
```

### 核心记忆点

- **6个假值**：`undefined`、`null`、`false`、`0`、`NaN`、`""` → 取反为 `true`。
- **其他值**：取反为 `false`。
- **双取反 `!!`**：快速将值转为布尔值，等价于 `Boolean(value)`。

## 且运算符

多个条件都要满足

> 如果一个人一直做好事，突然有一天做了一件坏事，那么人们会认为这个人很虚伪，以前说不定都是装的！对这个人不在认可
> 

```jsx
console.log(10 < 20 && 10 > 5); // true
```

## 或运算符

满足一个条件即可

> 如果一个人一直做坏事，突然有一天做了一件好事，那么人们认为这个人其实还不错，以前也许是另有原因！对这个人突然就认可了
> 

```jsx
console.log(10 < 20 || 10 < 5); // true
```






JavaScript还有一个三元运算符（即改运算符需要三个运算子）`?`  ，也可用于与逻辑判断。

```jsx
(条件) ? 表达式1 : 表达式2；
```

这个三元运算符可以被视为i`f…else` 的简写形式

## 判断奇偶

### if…else语句

```jsx
var n = 100;
if (n % 2 === 0){
		console.log("偶数");
} 
else {
		console.log("奇数");
}
```

### 三元运算符

```jsx
var n = 10;
n % 2 === 0 ? '偶数' : '奇数';
```





if结构先判断一个表达式的布尔值，然后根据布尔值的真伪执行不同的语句。所谓布尔值，指的是JavaScript 的两个特殊值，true 表示为真，false 表示为假。

## 语法语句规范

```jsx
if (布尔值){
		语句;
}
```

布尔值往往由一个条件表达式产生的，必须放在圆括号中

```jsx
var m = 3;
if (m === 3){
		m++;
}
console.log(m);//4
```

注意，if后面的表达式之中，不要混淆赋值表达式`(=)` ，严格表达式`(===)`和相等运算符`(==)`。尤其是赋值表达式不具备比较作用。

```jsx
var x = 1;
var y = 2;
if (x = y/*错误*/){
		console.log(x);
}
```




## if…else基本结构

if代码后面，还可以跟一个else代码块，表示不满足条件时，所要执行的代码。

![image.png](attachment:4cb56b27-f5a6-4e75-9876-afd0055ee182:image.png)

```jsx
if (m === 3){
		//满足条件时，执行的语句
} else {
		//不满足条件时，执行的语句
}
```

## 多个if…else连接

对同一个变量进行多次判断时，多个if…else语句可以连写在一起。

![image.png](attachment:9709e07a-8621-4108-8d7e-5d5ec455e5e7:image.png)

```jsx
if ( m === 0){
		//...
} 
else if（ m === 1){
		//...
}
else if ( m === 2){
		//...
} 
else {
		//...
}
```




多个if…else语句连用时，可以采用更加方便的switch结构

![image.png](attachment:bf991ffb-fbea-4b3b-b1fe-bcb8fb04d0a5:image.png)

```jsx
switch (fruit){
		case "banana":
				//...
				break;
		case "apple":
				//...
				break;
		default:
				 //...
}
```

需要注意的事，每个case代码块内部的break语句不能少，否则会去执行下一个case代码块，而不是跳出switch结构。

```jsx
var x = 1;

switch (x){
		case 1:
				console.log('x = 1');
		case 2:
				console.log('x = 2');
		default:
				console.log('x等于其他值');
}
/*
	输出结果为:  
	x = 1
	x = 2
	x等于其他值
*/
```





循环语句用于重复执行某个操作
for语句就是循环命令，可以指定循环的起点、终点和终止条件。它的格式如下：

```jsx
for ( 初始化表达式; 条件; 迭代因子){
		语句;
}
```

for语句后面的括号里面，有三个表达式：

1. 初始化表达式i`nitialize`：确定循环变量的初始值，只在循环开始时执行一次。
2. 布尔表达式`test`：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。
3. 迭代因子`increment`：每轮循环的最后一个操作，通常用来递增循环变量。

![image.png](attachment:72993d40-fb17-4207-b8b1-167195457d4d:image.png)

```jsx
var x = 3;
for ( var i = 0; i < x; i++){
			console.log('hello world');
}
```

for语句的三个表达式，可以省略任何一个，也可以全部省略。

```jsx
for ( ; ; ){
			console.log('hello world');
}
```




while语句是包括一个循环条件和一段代码块，只要条件为真，就会不断执行代码块。

```jsx
while (条件){
		语句;
}
```

![image.png](attachment:160ab12a-e108-44f0-8447-a5d3e3cb0dbb:image.png)




break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。

## break

break语句用于跳出代码块或循环

```jsx
for ( var i = 0; i < 5; i++){
				if (i === 3){
						break;
				}
				console.log(i);
}
```

## continue

continue语句用于立刻终止本轮循环，返回循环结构的头部，开始下一轮循环

```jsx
for ( var i = 1; i < 5; i++){
			if (i === 3){
					continue;
			}
			console.log(i);
}
```

![image.png](attachment:3a85a6a9-89c9-4c3f-b9dc-9c8062d601b2:image.png)







### 定义

字符串就是零个或多个排在一起的字符，放在单引号或双引号之中

```jsx
'itbaizhan'
"itbaizhan"
```

### 引号嵌套规则

单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号

```jsx
'key = "value"'
"It's a long itbaizhan"
```

### 引号转义规则

如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此

```jsx
'Did she say \\'Hello\\'?'
// "Did she say 'Hello'?"

"Did she say \\"Hello\\"?"
// "Did she say "Hello"?"
```

<aside>
💡

### 温馨提示

字符串默认只能写在一行内，分成多行将会报错

如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠

</aside>

```jsx
var longString =
"Long \
 long \
 string";
longString;
// "Long long long string"
```

### length属性

length属性返回字符串的长度，该属性也是无法改变的

```jsx
var s = "happy birthday"
s.lenth // 9
```




### charAt 方法

`charAt` 方法返回指定位置的字符，参数是从 `0` 开始编号的

```jsx
var s = new String('itbaizhan');

s.charAt(1) // "t"
s.charAt(s.length - 1) // "n"
```

如果参数为负数，或大于等于字符串的长度，`charAt` 返回空字符串

```jsx
'itbaizhan'.charAt(-1) // ""
'itbaizhan'.charAt(9) // ""
```






### concat 方法

`concat` 方法用于连接两个字符串，返回一个新字符串，不改变原字符串

```jsx
var s1 = 'itbaizhan';
var s2 = 'sxt';

s1.concat(s2) // "itbaizhansxt"
s1 // "itbaizhan"
```

---

### 多参数支持

该方法可以接受多个参数

```jsx
'sxt'.concat('itbaizhan', 'bjsxt') // "sxtitbaizhanbjsxt"
```

---

### 非字符串参数处理

如果参数不是字符串，`concat` 方法会将其先转为字符串，然后再连接

```jsx
var one = 1;
var two = 2;
var three = '3';

''.concat(one, two, three) // "123"
```





