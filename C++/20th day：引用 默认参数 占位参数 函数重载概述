int main(){

    //引用的语法
    //数据类型 &别名 = 原名
    int a = 10;
    //创建引用
    int &b = a;

    cout << "a = " << a << endl;
    cout << "b = " << b << endl;

    b = 100;

    cout << "a = " << a << endl;
    cout << "b = " << b << endl;

    system("pause");
    return 0;
}




#include<iostream>
using namespace std;

int main(){

    int a = 10;
    //1.引用必须初始化
    //int &b;错误，必须要初始化
    int &b = a;

    //2.引用在初始化后，不可以改变
    int c = 20;

    b = c;//赋值操作而非更改引用

    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    cout << "c = " << c << endl;

    return 0;
}



#include<iostream>
using namespace std;

//交换函数

//1.值传递
void mySwap01(int a, int b){
    int temp = a;
    a = b;
    b = temp;
    cout << "swap01 a = " << a << endl;
    cout << "swap01 b = " << b << endl;
}

//2.地址传递
void mySwap02(int* a, int* b){
    int temp = *a;
    *a = *b;
    *b = temp;
}

//3.引用传递
void mySwap03(int &a, int &b){
    int temp = a;
    a= b;
    b = temp;
}

int main(){
    int a = 10;
    int b = 20;

    mySwap01(a, b);//值传递，形参不会修饰实参
    mySwap02(&a, &b);//地址传递，形参会修饰实参
    mySwap03(a, b);//引用传递，形参也会修饰实参

    cout << "a = " << a << endl;
    cout << "b = " << b << endl;

}



#include<iostream>
using namespace std;

//引用作函数的返回值
//1.不要返回局部变量的引用
int& test01(){
    int a = 10;//局部变量，存放于栈区
    return a;
}

//2.函数代用可作为左值
int& test02(){
    static int a = 10;//静态变量，存放于全局区，全局区上的数据在程序结束后释放
    return a;
}

int main(){
    int &ref01 = test01();

    cout << "ref01 = " << ref01 << endl;//如果结果正确，是因为编译器做了保存

    int &ref02 = test02();
    cout << "ref02 = " << ref02 << endl;
    test02() = 1000;//如果函数的返回值是引用，则这个函数调用可以作为左值
    cout << "ref02 = " << ref02 << endl;

    return 0;
}



//发现是引用，转换为 int* const ref = &a;
void func(int& ref){
    ref = 100; // ref是引用，转换为*ref = 100
}

int main(){
    int a = 10;

    //自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改
    int& ref = a;
    ref = 20; //内部发现ref是引用，自动帮我们转换为：*ref = 20;

    cout << "a:" << a << endl;
    cout << "ref:" << ref << endl;

    func(a);
    return 0;
}




//引用使用的场景，通常用来修饰形参
void showValue(const int& v) {
    //v += 10;
    cout << v << endl;
}

int main() {
    //int& ref = 10; 引用本身需要一个合法的内存空间，因此这行错误
    //加入const就可以了，编译器优化代码，int temp = 10; const int& ref = temp;
    const int& ref = 10;

    //ref = 100; //加入const后不可以修改变量
    cout << ref << endl;

    //函数中利用常量引用防止误操作修改实参
    int a = 10;
    showValue(a);

    system("pause");

    return 0;
}





#include<iostream>
using namespace std;

//函数默认参数
//如果我们自己传入数据，就用我们自己的数据，如果没有，那么就用默认值
//语法：返回值类型 函数名(形参 = 默认值){}
int func1(int a, int b = 20, int c = 30){
    return a+b+c;
}

//注意事项
//1.如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值
// int func2(int a, int b = 10, int c){
//     return a+b+c;
// }

//2.如果函数声明有默认参数，函数实现就不能有默认参数
//声明和实现只能有一个默认参数
int func3(int a = 10, int b = 20);
int func3(int a = 30, int b = 40){
    return a+b;
}

int main(){
    cout << func1(10) << endl;
    cout << func3(10, 10) << endl;
    
    return 0;
}





//占位参数
//返回值类型 函数名(数据类型){}
//占位参数还可以有默认参数
void func(int a, int = 10){
    cout << "this is function" << endl;
}

int main(){
    func(10, 10);

}




#include<iostream>
using namespace std;

//函数重载
//可以让函数名相同，提高复用性

//函数重载的满足条件
//1.同一个作用域下
//2.函数名称相同
//3.函数参数 类型不同，或者 个数不同 又或 顺序不同
void func(){
    cout << "func的调用" << endl;
}

void func(int a){
    cout << "func(int a)的调用: a = " << a << endl;
}

void func(double a){
    cout << "func(double a)的调用: a = " << a << endl;
}

void func(int a, double b){
    cout << "func(int a, double b)的调用: a = " << a << ",b = " << b << endl;
}
void func(double a, int b){
    cout << "func(double a, int b)的调用: a = " << a << ",b = " << b << endl;
}
//注意事项
//函数的返回值不可以作为函数重载的条件
//  int func(){
//      cout << "此方程无法运行，同名函数不同返回值会存在二义性" << endl;
//      return 0;
//  }

int main(){
    func();
    func(22);
    func(3.14);
    func(10, 3.14);
    func(3.14, 10);

    return 0;
}
