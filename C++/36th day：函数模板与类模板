#include <iostream>
#include <string>
using namespace std;

//模板的局限性
//模板并不是万能的，有些特定数据类型，需要用具体化做特殊实现

class Person{
    public:
        string name;
        int age;

        Person(string n, int a){
            name = n;
            age = a;
        }
};

//对比两个数据是否相等函数
template<typename T>
bool myCompare(T &a, T &b){
    return a == b;
}

//利用具体化Person的版本实现代码，具体化优先调用
template<>bool myCompare(Person &a, Person &b){
    return (a.age == b.age && a.name == b.name);
}

void test01(){
    int a = 10;
    int b = 20;
    if(myCompare(a, b)){
        cout << "a == b" << endl;
    }
    else {
        cout << "a != b" << endl;
    }
}

void test02(){
    Person p1("Jack", 10), p2("Jack", 10);

    if(myCompare(p1, p2)){
        cout << "p1 == p2" << endl;
    }
    else {
        cout << "p1 != p2" << endl;
    }
}

int main(){

    test01();
    test02();

    return 0;
}





#include <iostream>
#include <string>
using namespace std;

//类模板
template<class nameType, class ageType>
class Person{
    public:
        Person(nameType n, ageType a): name(n), age(a){}

        void showPerson(){
            cout << "name: " << name << endl;
            cout << "age: " << age << endl;
        }

        nameType name;
        ageType age;
};

void test01(){
    Person<string, int> p1("Tom", 12);
    p1.showPerson();
}

int main(){

    test01();

    return 0;
}





#include <iostream>
#include <string>
using namespace std;

//类模板和函数模板的区别
template<class nT = string, class aT = int>
class Person{
    public:
        Person(nT n, aT a): name(n), age(a){}

        void showPerson(){
            cout << "name: " << name << endl;
            cout << "age: " << age << endl;
        }

        nT name;
        aT age;
};

//1.类模板没有自动类型推导的使用方式
void test01(){
    Person p1("Jack", 12);// C++17后就支持自动类型推导了
    Person<string, int> p2("Bob", 13);

    p1.showPerson();
    p2.showPerson();
}

//2.类模板在参数列表列表中可以有默认参数
void test02(){
    Person<string> p("Metatron", 19);
    p.showPerson();
}


int main(){

    test01();
    test02();

    return 0;
}
