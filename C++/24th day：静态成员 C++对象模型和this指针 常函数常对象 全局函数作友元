#include <iostream>
using namespace std;

//静态成员变量
class Person{
    public:
        //1.所有对象都共享同一份数据
        //2.编译阶段就分配内存
        //3.类内声明，类外初始化操作
        static int age;
    
    //静态成员变量也有访问权限
    private:
        static int height;
};

int Person::age = 11;
int Person::height = 121;

void test1(){
    Person p;
    cout << p.age << endl;

    Person p2;
    p2.age = 12;
    cout << p.age << endl;
}

void test2(){
    //静态成员不属于某个对象上，所有对象都共享同一份数据
    //因此静态成员变量有两周访问方式

    //1.通过对象进行访问
    Person p;
    cout << p.age << endl;
    
    //2.通过类名进行访问
    cout << Person::age << endl;
    //cout << Person::height << endl; 类外访问不到私有静态成员变量
}

int main(){

    test1();
    test2();

    return 0;
}





#include <iostream>
using namespace std;

//静态成员函数
//所有成员共享同一个函数
//静态成员函数只能访问静态成员变量

class Person{
    public:
        //静态成员函数
        static void func(){
            a = 100;//静态成员函数 可以访问 静态成员变量
            //n = 12; 静态成员函数 不可以访问 非静态成员变量，因为无法区分这个普通
            // 变量到底是属于哪个对象的属性。这里就对应了 所有对象共享同一个静态函数
            
            /*在C++中，静态成员函数不能直接访问非静态成员变量，原因并不是
            因为它们存储在不同的内存区域（尽管静态成员和非静态成员确实存储
            在不同的内存区域），而是因为静态成员函数没有隐含的this指针。*/

            cout << "静态函数调用" << endl;
        }

        static int a;//静态成员变量
        int n;//非静态成员变量
    
    //静态成员也是有访问权限的
    private:
        static void func2(){
            cout << "静态函数2的调用" << endl;
        }
};

int Person::a = 0;

//有两种访问方式
void test1(){
    //1.通过对象访问
    Person p;
    p.func();

    //2.通过类名访问
    Person::func();
    //Person::func2(); 类外访问不到私有的静态成员函数
}

int main(){

    test1();

    return 0;
}






#include <iostream>
using namespace std;

//成员变量 和 成员函数 分开储存
class Person{
    public:
        int a;//非静态成员变量 属于类对象上

        static int b;//静态成员变量 不属于类对象上

        void func(){}//非静态成员函数 不属于类对象上

        static void func2(){}//静态成员函数 不属于类对象上
};

int Person::b = 0;

void test01(){
    Person p;
    //空对象占用的内存空间
    //C++编译器会给每个空对象分配一个字节空间，是为了区分空对象占内存的位置
    //每个空对象也应该有一个独一无二的内存地址
    cout << "size of p = " << sizeof(p) << endl;
}

void test02(){
    Person p;
    cout << "size of p = " << sizeof(p) << endl;
}

int main(){

    // test01();
    test02();

    return 0;
}






#include <iostream>
using namespace std;

class Person{
    public:
        int age;

        Person(int age){
            // this 指针指向被调用的成员函数所属对象
            this->age = age;
        }

        /*为什么要用引用`&`？
          因为不用引用返回值返回的是person的拷贝，用引用相当于返回的是person的地址。*/
        Person& PersonAddAge(Person &p){
            this->age += p.age;

            return *this;
        }
};

//1.解决名称冲突
void test01(){
    Person p1(18);
    cout << "p1的年龄为: " << p1.age << endl;
}

//2.返回对象本身 *this
void test02(){
    Person p1(10);

    Person p2(10);

    //链式编程思想
    p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);

    cout << "p2's age is " << p2.age << endl;
}

int main(){

    test01();
    test02();

    return 0;
}






#include <iostream>
using namespace std;

//空指针调用成员函数
class Human{
    public:
        void showClassName(){

            cout << "this is Human class" << endl;
        }

        void showAge(){
            //报错原因是因为传入的指针是为NULL
            if (this == NULL){
                return;
            }
            cout << "age is" << age << endl;
        }

        int age;
};

void test01(){
    Human *p = NULL;
    p->showAge();
    p->showClassName();
}

int main(){
    test01();
    return 0;
}






#include <iostream>
using namespace std;

//常函数
class Human{
    public:
        // this 指针的本质 是指针常量  指针的指向是不可修改的
        // const Human * const this;
        // 在成员函数后面加const，修饰的是this指针，让其指向的值也变得不可修改
        void showHuman() const {
            this->b = 100;
            // age = 100;
            // this = NULL; this 指针不可以修改指针的指向
        }

        void nullFunc(){}

        int age;
        mutable int b;// 特殊变量，即使在常函数中，也可以修改这个值，加关键字mutable
};

void test01(){
    Human p;
    p.showHuman();
}

//常对象
void test02(){
    const Human h{0, 0};//在对象面前加const，变为常对象
    // h.age = 100;
    h.b = 100;// b是特殊值，在常对象下也可以修改

    //常对象只能调用常函数
    h.showHuman();
    // h.nullFunc(); 常对象  不可以调用普通成员函数，因为普通成员函数可以修改属性
}

int main(){

    test01();
    test02();

    return 0;
}







#include <iostream>
#include <string>
using namespace std;

//建筑物类
class Building{
    //goodGuy全局函数是 Building类的友元，可以访问Building中的私有成员
    friend void goodGuy(Building &b);

    public:
        Building(): settingroom("客厅"), bedroom("卧室"){}
        string settingroom;

    private:
        string bedroom;
};

//全局函数
void goodGuy(Building &b){
    cout << "The \"goodGuy\" global function is visiting: " << b.settingroom <<endl;

    cout << "The \"goodGuy\" global function is visiting: " << b.bedroom <<endl;
}  

void test1(){
    Building b;
    goodGuy(b);
}

int main(){

    test1();

    return 0;
}




