#include <iostream>
using namespace std;

//多态

//动物类
class Animal{
    public:
        //Speak函数就是虚函数
        //在函数前面加上virtual关键字变成虚函数，那么编译器在编译的时候就不能确定函数的调用了
        virtual void speak(){
            cout << "Animal is speaking." << endl;
        }
};

//猫类
class Cat: public Animal{
    public:
        //重写：  函数返回值类型 函数名 参数列表 完全相同
        void speak(){
            cout << "The cat is speaking." << endl;
        }
};

//狗类
class Dog: public Animal{
    public:
        void speak(){
            cout << "The dag is speaking." << endl;
        }
};

//执行说话的函数
//地址早绑定   在编译阶段确定地址
//如果想执行让猫说话，那么这个函数地址就不能提前绑定，需要晚绑定

//动态多态满足条件
//1.有继承关系
//2.子类要重写父类的虚函数(重写：函数返回值类型 函数名 参数列表 要全部完全相同)

//动态多态的调用
// 父类的指针或者引用 指向子对象

void doSpeak(Animal &a){//Animal &a = cat
    a.speak();
}

void test1(){
    Cat c;
    doSpeak(c);

    Dog d;
    doSpeak(d);
}

//如果函数地址在编译阶段就能确定，就是静态联编
//如果函数地址在运行阶段才能确定，就是动态联编

int main(){

    test1();

    return 0;
}




#include <iostream>
#include <string>
using namespace std;

//分别利用普通写法和多态写法实现计算器

//普通写法
class Calculator{
    public:

        double getResult(string oper){
            if (oper == "+"){
                return n1 + n2;
            }
            else if (oper == "-"){
                return n1 - n2;
            }
            else if (oper == "*"){
                return n1 * n2;
            }
            else if (oper == "/"){
                return n1 / n2;
            }
            return 0;
            
            //如果想扩展新的功能，需求修改源码
            //在真实开发中 提倡 开闭原则
            //开闭原则：对扩展进行开放，对修改进行封闭
        }

        double n1, n2;
};

void test01(){
    //创建计算器对象
    Calculator c;
    c.n1 = 10;
    c.n2 = 20;

    cout << c.n1 << "+" << c.n2 << "=" << (int)c.getResult("+") << endl;
    cout << c.n1 << "-" << c.n2 << "=" << (int)c.getResult("-") << endl;
    cout << c.n1 << "*" << c.n2 << "=" << (int)c.getResult("*") << endl;
    cout << c.n1 << "/" << c.n2 << "=" << c.getResult("/") << endl;
}

//利用多态实现计算器

//多态好处：
//1.组织结构清晰
//2.可读性强
//3.对于前期和后期的扩展和维护性高

//实现计算器抽象类
class AbstractCalculator{
    public:
        virtual double getResult() = 0;// 纯虚函数：无实现，类变成抽象类
        virtual ~AbstractCalculator() = default;//把析构函数也转换为虚函数，防止后续delete的时候只调用基类而不调用派生类，从而造成资源浪费甚至二次释放
                                                //default：告诉编译器执行默认的析构函数
        int n1, n2;
};

//override：告诉编译器这个函数是重写的父类的虚函数
//好处在于，如果不小心写错函数名或者参数，编译器会直接报错，避免 “重写失败” 的隐藏 bug

//加法运算器类
class AddCalculator: public AbstractCalculator{
    public:
        double getResult() override{
            return n1 + n2;
        }
};

//减法计算器类
class SubCalculator: public AbstractCalculator{
    public:
        double getResult() override{
            return n1 - n2;
        }
};

//乘法计算器类
class MulCalculator: public AbstractCalculator{
    public:
        double getResult() override{
            return n1 * n2;
        }
};

//除法计算器类
class DivCalculator: public AbstractCalculator{
    public:
        double getResult() override{
            return (double)n1 / n2;
        }
};

void test02(){
    //多态使用条件
    //父类指针或者引用指向子类对象

    //加法
    AbstractCalculator *ab = new AddCalculator;
    ab->n1 = 10;
    ab->n2 = 20;
    cout << ab->n1 << "+" << ab->n2 << "=" << ab->getResult() << endl;
    //用完后销毁
    delete ab;

    //减法
    ab = new SubCalculator;
    ab->n1 = 10;
    ab->n2 = 20;
    cout << ab->n1 << "-" << ab->n2 << "=" << ab->getResult() << endl;
    //用完后销毁
    delete ab;

    //乘法
    ab = new MulCalculator;
    ab->n1 = 10;
    ab->n2 = 20;
    cout << ab->n1 << "*" << ab->n2 << "=" << ab->getResult() << endl;
    //用完后销毁
    delete ab;

    //除法
    ab = new DivCalculator;
    ab->n1 = 10;
    ab->n2 = 20;
    cout << ab->n1 << "/" << ab->n2 << "=" << ab->getResult() << endl;
    //用完后销毁
    delete ab;
    ab = nullptr;
}

int main(){
    cout << "普通实现" << endl;
    test01();
    cout << "\n多态实现" << endl;
    test02();

    return 0;
}
