#include <iostream>
#include <string>
using namespace std;

//类模板中成员函数创建时机
//类模板中的成员函数在调用时才能创建

class Person1{
    public:
        void showPerson1(){
            cout << "Person1 show" << endl;
        }
};

class Person2{
    public:
        void showPerson2(){
            cout << "Person2 show" << endl;
        }
};

template<class T>
class myClass{
    public:
        T obj;

        //类模板中成员函数
        void func1(){
            obj.showPerson1();
        }

        void func2(){
            obj.showPerson2();
        }
};

void test01(){
    myClass<Person1> p1;
    p1.func1();
    // p1.func2();  
}

int main(){

    test01();

    return 0;
}






#include <iostream>
#include <string>
using namespace std;

//类模板对象做函数参数
template<class T1, class T2>
class Person{
    public:
        Person(T1 n, T2 a): name(n), age(a){}

        void showPerson(){
            cout << name << endl;
            cout << age << endl;
        }

        T1 name;
        T2 age;
};

//1.指定传入类型
void prinitPerson1(Person<string, int> &p){
    p.showPerson();
}

void test01(){
    Person<string, int> p1("a", 13);
    prinitPerson1(p1);
}

//2.参数模板化
template<class T1, class T2>
void prinitPerson2(Person<T1, T2> &p){
    p.showPerson();
    cout << "T1的类型为：" << typeid(T1).name() << endl;
    cout << "T2的类型为：" << typeid(T2).name() << endl;
}

void test02(){
    Person<string, int> p2("b", 14);
    prinitPerson2(p2);
}

//3.整个类模板化
template<class T>

void printPerson3(T &p){
    p.showPerson();
    cout << "T的数据类型:" << typeid(T).name() << endl;
}

void test03(){
    Person<string, int> p3("c", 15);
    printPerson3(p3);
}

int main(){

    test01();
    test02();
    test03();

    return 0;
}







#include <iostream>
#include <string>
using namespace std;

//类模板与继承
template<class T>
class Base{
    public:
        T m;
};

// class Son: public Base 错误，必须要知道父类中的T类型才能继承给子类
class Son: public Base<int>{

};

void test01(){
    Son s1;
}

//如果想灵活的指定父类中T类型，子类也需要变类模板
template<class T1, class T2>
class Son2: public Base<T2>{
    public:
        Son2(){
            cout << "T1的类型为：" << typeid(T1).name() << endl;
            cout << "T2的类型为：" << typeid(T2).name() << endl;
        }

        T1 obj;
};

void test02(){
    Son2<int, char> s2;
}

int main(){

    test01();
    test02();

    return 0;
}
